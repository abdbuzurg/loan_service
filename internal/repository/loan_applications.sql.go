// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: loan_applications.sql

package repository

import (
	"context"
)

const countApplicationsByUser = `-- name: CountApplicationsByUser :one
select count(*)
from loan_applications
where user_id = $1
`

func (q *Queries) CountApplicationsByUser(ctx context.Context, userID int64) (int64, error) {
	row := q.db.QueryRow(ctx, countApplicationsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createApplication = `-- name: CreateApplication :one
INSERT INTO loan_applications(
  user_id,
  type,
  vehicle_vin,
  vehicle_name,
  currency_code,
  price,
  down_payment,
  net_price,
  margin_rate,
  term_months,
  monthly_payment,
  status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12  
) RETURNING id, user_id, type, vehicle_vin, vehicle_name, currency_code, price, down_payment, net_price, margin_rate, term_months, monthly_payment, status, created_at, updated_at
`

type CreateApplicationParams struct {
	UserID         int64                 `json:"user_id"`
	Type           ApplicationType       `json:"type"`
	VehicleVin     *string               `json:"vehicle_vin"`
	VehicleName    *string               `json:"vehicle_name"`
	CurrencyCode   string                `json:"currency_code"`
	Price          *float64              `json:"price"`
	DownPayment    *float64              `json:"down_payment"`
	NetPrice       *float64              `json:"net_price"`
	MarginRate     *float64              `json:"margin_rate"`
	TermMonths     *int64                `json:"term_months"`
	MonthlyPayment *float64              `json:"monthly_payment"`
	Status         NullApplicationStatus `json:"status"`
}

func (q *Queries) CreateApplication(ctx context.Context, arg CreateApplicationParams) (LoanApplication, error) {
	row := q.db.QueryRow(ctx, createApplication,
		arg.UserID,
		arg.Type,
		arg.VehicleVin,
		arg.VehicleName,
		arg.CurrencyCode,
		arg.Price,
		arg.DownPayment,
		arg.NetPrice,
		arg.MarginRate,
		arg.TermMonths,
		arg.MonthlyPayment,
		arg.Status,
	)
	var i LoanApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.VehicleVin,
		&i.VehicleName,
		&i.CurrencyCode,
		&i.Price,
		&i.DownPayment,
		&i.NetPrice,
		&i.MarginRate,
		&i.TermMonths,
		&i.MonthlyPayment,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getApplication = `-- name: GetApplication :one
select id, user_id, type, vehicle_vin, vehicle_name, currency_code, price, down_payment, net_price, margin_rate, term_months, monthly_payment, status, created_at, updated_at
from loan_applications
where id = $1
`

func (q *Queries) GetApplication(ctx context.Context, id int64) (LoanApplication, error) {
	row := q.db.QueryRow(ctx, getApplication, id)
	var i LoanApplication
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Type,
		&i.VehicleVin,
		&i.VehicleName,
		&i.CurrencyCode,
		&i.Price,
		&i.DownPayment,
		&i.NetPrice,
		&i.MarginRate,
		&i.TermMonths,
		&i.MonthlyPayment,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listApplicationsByUser = `-- name: ListApplicationsByUser :many
select id, user_id, type, vehicle_vin, vehicle_name, currency_code, price, down_payment, net_price, margin_rate, term_months, monthly_payment, status, created_at, updated_at
from loan_applications
where user_id = $1
order by id desc
limit $2
offset $3
`

type ListApplicationsByUserParams struct {
	UserID int64 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListApplicationsByUser(ctx context.Context, arg ListApplicationsByUserParams) ([]LoanApplication, error) {
	rows, err := q.db.Query(ctx, listApplicationsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoanApplication
	for rows.Next() {
		var i LoanApplication
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Type,
			&i.VehicleVin,
			&i.VehicleName,
			&i.CurrencyCode,
			&i.Price,
			&i.DownPayment,
			&i.NetPrice,
			&i.MarginRate,
			&i.TermMonths,
			&i.MonthlyPayment,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
